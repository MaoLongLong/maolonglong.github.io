<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Pool on 毛珑珑的博客</title><link>https://maolonglong.github.io/tags/Pool/</link><description>Recent content in Pool on 毛珑珑的博客</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Mon, 28 Jun 2021 19:42:29 +0800</lastBuildDate><atom:link href="https://maolonglong.github.io/tags/Pool/index.xml" rel="self" type="application/rss+xml"/><item><title>高性能字节池设计 | bytebufferpool 源码分析</title><link>https://maolonglong.github.io/post/golang/bytebufferpool/</link><pubDate>Mon, 28 Jun 2021 19:42:29 +0800</pubDate><guid>https://maolonglong.github.io/post/golang/bytebufferpool/</guid><description>简介 今天的主角是 bytebufferpool ，仓库的 README 文件是这么描述 bytebufferpool 的： Currently bytebufferpool is fastest and most effective buffer pool written in Go. bytebufferpool 基本上是目前 Go 实现的最快的字节池，在许多优秀项目中都有被使用（fasthttp, quicktemplate, gnet） 什么是字节池？在读取文件或者从 io.Reader 获取数据时，一般都需要创建一个字节切片 []byte 作为缓冲，如果对于这种方法有大量的调用，就</description></item></channel></rss>